// background.js

// Define the base API URL
const API_URL = 'https://kevin.gtfkd.com/kev/exists';

// Cache expiration time in milliseconds (10 minutes)
const CACHE_EXPIRATION = 10 * 60 * 1000; // 600,000 ms

// In-memory cache (optional)
const backgroundCache = {};

// Function to check KEV status for a given CVE ID with persistent caching and in-memory caching
async function checkKEV(cveId) {
  try {
    const currentTime = Date.now();

    // Check in-memory cache first
    if (backgroundCache[cveId]) {
      const { inKEV, timestamp } = backgroundCache[cveId];

      // Check if cached data is still valid
      if (currentTime - timestamp < CACHE_EXPIRATION) {
        console.log(`In-memory cache hit for ${cveId}:`, inKEV);
        return { cveId, inKEV };
      } else {
        console.log(`In-memory cache expired for ${cveId}. Removing entry.`);
        delete backgroundCache[cveId];
      }
    }

    // Check persistent cache in chrome.storage.local
    const cachedData = await chrome.storage.local.get(cveId);
    if (cachedData[cveId]) {
      const { inKEV, timestamp } = cachedData[cveId];
    
      // Verify that timestamp exists and is a number
      if (typeof timestamp !== 'number' || typeof inKEV !== 'boolean') {
        console.warn(`Cached data for ${cveId} is invalid. Removing entry.`);
        await chrome.storage.local.remove(cveId);
      } else if (currentTime - timestamp < CACHE_EXPIRATION) {
        console.log(`Persistent cache hit for ${cveId}:`, inKEV);
        // Update in-memory cache
        backgroundCache[cveId] = { inKEV, timestamp };
        return { cveId, inKEV };
      } else {
        console.log(`Persistent cache expired for ${cveId}. Removing entry.`);
        // Remove expired cache entry
        await chrome.storage.local.remove(cveId);
      }
    }

    // Fetch fresh data from the KEV API
    const url = `${API_URL}?cve=${cveId}`;
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'x-kevin-source': 'Chrome Extension',
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    const inKEV = data.In_KEV;

    // Store the result with the current timestamp in both in-memory and persistent caches
    const cacheEntry = { inKEV, timestamp: currentTime };
    backgroundCache[cveId] = cacheEntry;

    // Store in chrome.storage.local
    const storageEntry = {};
    storageEntry[cveId] = cacheEntry;
    await chrome.storage.local.set(storageEntry);

    console.log(`Fetched and cached data for ${cveId}:`, inKEV);
    return { cveId, inKEV };
  } catch (error) {
    console.error(`Error fetching KEV data for ${cveId}:`, error);
    // In case of an error, assume the CVE is not in KEV to prevent blocking
    return { cveId, inKEV: false, error: error.message };
  }
}

// Function to clean up expired cache entries
async function cleanUpCache() {
  const allItems = await chrome.storage.local.get(null); // Get all items
  const currentTime = Date.now();
  const keysToRemove = [];

  for (const [cveId, data] of Object.entries(allItems)) {
    if (typeof data.timestamp === 'number') {
      if (currentTime - data.timestamp >= CACHE_EXPIRATION) {
        keysToRemove.push(cveId);
      }
    } else {
      console.warn(`Cached data for ${cveId} is missing a valid timestamp. Removing entry.`);
      keysToRemove.push(cveId);
    }
  }

  if (keysToRemove.length > 0) {
    await chrome.storage.local.remove(keysToRemove);
    console.log(`Cleaned up expired cache entries: ${keysToRemove.join(', ')}`);
  }
}

// Schedule cache cleanup every 20 minutes
setInterval(() => {
  cleanUpCache().catch(error => {
    console.error('Error in scheduled cache cleanup:', error);
  });
}, 20 * 60 * 1000);

// Listener for messages from content scripts
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'checkKEV') {
    const cveId = request.cveId;

    // Call the checkKEV function and respond
    checkKEV(cveId)
      .then(result => sendResponse(result))
      .catch(error => {
        console.error('Error in background script:', error);
        sendResponse({ cveId, inKEV: false, error: error.message });
      });

    // Return true to indicate that the response is asynchronous
    return true;
  }
});