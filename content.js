// content.js

// Define the base URL for the vulnerability details page
const VULNERABILITY_BASE_URL = 'https://nvd.nist.gov/vuln/detail/'; // Replace with your actual URL

// Regular expression to match CVE IDs (e.g., CVE-2023-1234)
const CVE_REGEX = /\bCVE-\d{4}-\d{4,8}\b/g;

// Cache to store KEV API responses to prevent redundant requests
const kevCache = {};

// Debounce timer for MutationObserver
let debounceTimer;

// Function to process text nodes and highlight CVE IDs
function highlightCVEs(node) {
  const processNode = (node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      const parent = node.parentNode;

      if (parent.tagName === 'A' && parent.href.startsWith(VULNERABILITY_BASE_URL)) {
        return;
      }

      const text = node.nodeValue;
      const matches = text.match(CVE_REGEX);

      if (matches) {
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;

        text.replace(CVE_REGEX, (match, index) => {
          fragment.appendChild(document.createTextNode(text.substring(lastIndex, index)));

          const span = document.createElement('span');
          span.className = 'cve-highlight';
          span.textContent = match;

          const link = document.createElement('a');
          link.href = VULNERABILITY_BASE_URL + match;
          link.target = '_blank';
          link.appendChild(span);

          fragment.appendChild(link);
          lastIndex = index + match.length;
        });

        fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        parent.replaceChild(fragment, node);
      }
    } else if (node.nodeType === Node.ELEMENT_NODE && !['SCRIPT', 'STYLE'].includes(node.tagName)) {
      node.childNodes.forEach(processNode);
    }
  };

  processNode(node);
}

// Function to initiate highlighting on the entire document
async function initiateHighlighting() {
  highlightCVEs(document.body);
  await checkKEVCatalog();
}

// Function to collect unique CVE IDs and check against KEV Catalog
async function checkKEVCatalog() {
  const cveElements = document.querySelectorAll('a[href^="' + VULNERABILITY_BASE_URL + '"] .cve-highlight');
  const cveSet = new Set();

  cveElements.forEach(elem => {
    const cveText = elem.textContent.trim();
    if (CVE_REGEX.test(cveText)) {
      cveSet.add(cveText);
    }
  });

  const uniqueCVEs = Array.from(cveSet);
  if (uniqueCVEs.length === 0) return;

  // Function to check a single CVE via background script
  function checkCVE(cve) {
    return new Promise((resolve, reject) => {
      // If CVE is already in cache, use it
      if (kevCache[cve] !== undefined) {
        resolve({ cveId: cve, inKEV: kevCache[cve] });
        return;
      }

      // Send message to background script
      chrome.runtime.sendMessage({ action: 'checkKEV', cveId: cve }, response => {
        if (chrome.runtime.lastError) {
          console.error('Runtime error:', chrome.runtime.lastError);
          resolve({ cveId: cve, inKEV: false });
        } else {
          kevCache[cve] = response.inKEV;
          resolve(response);
        }
      });
    });
  }

  // Limit the number of concurrent API requests
  const concurrencyLimit = 5;
  let activePromises = [];

  for (const cve of uniqueCVEs) {
    const promise = checkCVE(cve).then(data => {
      if (data.inKEV) {
        // Add tooltip icon next to each CVE element
        cveElements.forEach(elem => {
          if (elem.textContent.trim() === cve && !elem.parentNode.querySelector('.kev-tooltip')) {
            const tooltip = document.createElement('span');
            tooltip.className = 'kev-tooltip';
            tooltip.textContent = '!';
            tooltip.setAttribute('data-tooltip', 'CVE is listed in the CISA Known Exploited Vulnerabilities Catalog.');
            elem.parentNode.insertBefore(tooltip, elem.nextSibling);
          }
        });
      }
    });

    activePromises.push(promise);

    if (activePromises.length >= concurrencyLimit) {
      await Promise.race(activePromises);
      activePromises = activePromises.filter(p => !p.isFulfilled);
    }
  }

  // Wait for all remaining promises to resolve
  await Promise.all(activePromises);
}

// Debounce function to limit the rate of function execution
function debounce(func, delay) {
  return function(...args) {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => func.apply(this, args), delay);
  };
}

// Observe dynamically added content to handle single-page applications or AJAX-loaded content
const observer = new MutationObserver(debounce(async (mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      highlightCVEs(node);
    });
  });
  await checkKEVCatalog();
}, 300)); // Adjust the delay as needed

// Start observing the document body for changes
observer.observe(document.body, { childList: true, subtree: true });

// Run the highlighting and KEV check functions after the DOM is fully loaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initiateHighlighting);
} else {
  initiateHighlighting();
}