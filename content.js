// content.js

// Define the base URL for the vulnerability details page
const VULNERABILITY_BASE_URL = 'https://nvd.nist.gov/vuln/detail/'; // Replace with your actual URL

// Regular expression to match CVE IDs (e.g., CVE-2023-1234)
const CVE_REGEX = /\bCVE-\d{4}-\d{4,8}\b/g;

// Debounce timer for MutationObserver
let debounceTimer;

// Maximum number of concurrent API requests
const MAX_CONCURRENT_REQUESTS = 5;

// Queue to manage pending CVE checks
const cveQueue = [];

// Current number of active API requests
let activeRequests = 0;

// Function to process text nodes and highlight CVE IDs
function highlightCVEs(node) {
  const processNode = (node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      const parent = node.parentNode;

      // Skip if the parent is a link to the vulnerability page
      if (parent.tagName === 'A' && parent.href.startsWith(VULNERABILITY_BASE_URL)) {
        return;
      }

      const text = node.nodeValue;
      const matches = text.match(CVE_REGEX);

      if (matches) {
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;

        text.replace(CVE_REGEX, (match, index) => {
          // Append text before the match
          fragment.appendChild(document.createTextNode(text.substring(lastIndex, index)));

          // Create a span to highlight
          const span = document.createElement('span');
          span.className = 'cve-highlight';
          span.textContent = match;

          // Create a link to the vulnerability page
          const link = document.createElement('a');
          link.href = VULNERABILITY_BASE_URL + match;
          link.target = '_blank';
          link.appendChild(span);

          fragment.appendChild(link);
          lastIndex = index + match.length;
        });

        // Append any remaining text after the last match
        fragment.appendChild(document.createTextNode(text.substring(lastIndex)));

        // Replace the original text node with the new fragment
        parent.replaceChild(fragment, node);
      }
    } else if (node.nodeType === Node.ELEMENT_NODE && !['SCRIPT', 'STYLE'].includes(node.tagName)) {
      // Recursively process child nodes, excluding script and style tags
      node.childNodes.forEach(child => processNode(child));
    }
  };

  processNode(node);
}

// Function to initiate highlighting on the entire document
async function initiateHighlighting() {
  highlightCVEs(document.body);
  await checkKEVCatalog();
}

// Function to collect unique CVE IDs and check against KEV Catalog
async function checkKEVCatalog() {
  const cveElements = document.querySelectorAll('a[href^="' + VULNERABILITY_BASE_URL + '"] .cve-highlight');
  const cveSet = new Set();

  cveElements.forEach(elem => {
    const cveText = elem.textContent.trim();
    if (CVE_REGEX.test(cveText)) {
      cveSet.add(cveText);
    }
  });

  const uniqueCVEs = Array.from(cveSet);
  if (uniqueCVEs.length === 0) return;

  uniqueCVEs.forEach(cve => enqueueCVECheck(cve, cveElements));
  processQueue();
}

// Function to enqueue CVE checks
function enqueueCVECheck(cve, cveElements) {
  cveQueue.push({ cve, cveElements });
}

// Function to process the CVE queue with concurrency control
async function processQueue() {
  while (cveQueue.length > 0 || activeRequests > 0) {
    while (cveQueue.length > 0 && activeRequests < MAX_CONCURRENT_REQUESTS) {
      const { cve, cveElements } = cveQueue.shift();
      activeRequests++;
      checkCVE(cve, cveElements).finally(() => {
        activeRequests--;
        // No need to call processQueue() recursively
      });
    }
    // Short delay to allow active requests to complete
    await new Promise(resolve => setTimeout(resolve, 50));
  }
}

// Function to check a single CVE via background script
async function checkCVE(cve, cveElements) {
  try {
    const response = await chrome.runtime.sendMessage({ action: 'checkKEV', cveId: cve });
    if (response && response.inKEV) {
      addTooltipIcon(cve, cveElements);
    }
  } catch (error) {
    console.error('Error checking KEV Catalog for', cve, ':', error);
  }
}

// Function to add tooltip icon next to each CVE element
function addTooltipIcon(cve, cveElements) {
  cveElements.forEach(elem => {
    if (elem.textContent.trim() === cve) {
      // Check if tooltip already exists or if the element is already marked
      if (!elem.hasAttribute('data-kev-tooltip-added')) {
        const tooltip = document.createElement('span');
        tooltip.className = 'kev-tooltip';
        tooltip.textContent = '!';
        tooltip.setAttribute('data-tooltip', 'CVE is listed in the CISA Known Exploited Vulnerabilities Catalog.');
        elem.parentNode.insertBefore(tooltip, elem.nextSibling);

        // Mark the element as having a tooltip to prevent duplicates
        elem.setAttribute('data-kev-tooltip-added', 'true');
      }
    }
  });
}

// Debounce function to limit the rate of function execution
function debounce(func, delay) {
  return function(...args) {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => func.apply(this, args), delay);
  };
}

// Observe dynamically added content to handle single-page applications or AJAX-loaded content
const observer = new MutationObserver(debounce(async (mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      highlightCVEs(node);
    });
  });
  await checkKEVCatalog();
}, 300)); // Adjust the delay as needed

// Start observing the document body for changes
observer.observe(document.body, { childList: true, subtree: true });

// Run the highlighting and KEV check functions after the DOM is fully loaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initiateHighlighting);
} else {
  initiateHighlighting();
}